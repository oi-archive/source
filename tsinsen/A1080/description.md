<div id="pcont1" style="margin-top:20px; display:block;">

# 问题描述

<div class="pdcont">　　Fibonacci数是组合数学中非常重要的一个数列，它的递推公式是：<br/>
　　F(1)=F(2)=1<br/>
　　F(n)=F(n-1)+F(n-2)<br/>
　　当然，用这个公式来计算F(n)是非常慢的，当计算F(n)时需要从F(1)一直计算到F(n)。Fibonacci数列还满足一些其他的公式，如：<br/>
　　F(a+b+1)=F(a+1)*F(b+1)+F(a)*F(b)<br/>
　　利用这个公式，可以加速Fibonacci数的计算。我们考虑同时计算F(2n+1)和F(2n)，则按照上面的公式：<br/>
　　F(2n+1)=F(n+1)*F(n+1)+F(n)*F(n)<br/>
　　F(2n)=F(n+1)*F(n)+F(n)*F(n-1)=F(n+1)*F(n)+F(n)*(F(n+1)-F(n))<br/>
　　这样，F(2n+1)和F(2n)的计算变为了F(n+1)和F(n)的计算，即下标变为了原来的一半。重复利用这种方法，可以每次让下标变为原来的一半，总共需要大约log n次计算(以2为底)。<br/>
　　当n较大时，后面的方法就比直接的递推要快得多，比如当n=1000000时，后面的方法大概需要20次计算，而直接递推的方法大概需要1000000次计算，现在请你用这种方法计算F(n)和F(n+1)。<br/>
　　由于答案非常大，你只需要计算F(n)和F(n+1)除m的余数即可。<br/>
　　注意，上述公式在除m的余数下仍是满足的，即令g(n)是F(n)除m的余数，则<br/>
　　g(2n+1)=(g(n+1)*g(n+1)+g(n)*g(n))%m<br/>
　　g(2n)=(g(n+1)*g(n)+g(n)*(g(n+1)-g(n)+m))%m<br/>
　　在g(2n)的公式中多了一个+m，是为了在运算中不出现负数。<br/>
　　参数保证n为正整数，m不大于10000。</div>

</div>